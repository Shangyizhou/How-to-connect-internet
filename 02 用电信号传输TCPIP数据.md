## 了解重点

- 创建套接字
- 连接服务器
- 收发数据
- 从服务器断开连接并删除套接字
- IP与以太网的包收发操作
- 用UDP协议收发数据的操作

补充了很多有用的信息，我们发送数据本质是委托给操作系统，让操作系统里的Socket库里的组件发送的，这其中借助了协议栈，然后层层向下，最后传递过去。协议栈发送数据，那么它得知道发送给谁吧，所以知道IP地址和端口号，我们需要将这个信息告诉他，这些信息相当于一系列的属性，我们想让OS可以直接找到，把这些控制信息组合在一起，命名为套接字如何，是不是对套接字的形成有了一点印象。

## 创建套接字

协议栈内部结构

![image-20211120220115494](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211120220115494.png)

- 浏览器、邮件等一般应用程序收发数据时用 TCP； 

- DNS 查询等收发较短的控制数据时用 UDP。

### 套接字的实体就是通信控制信息

**协议栈是根据套接字中记录的控制信息来工作的**

我们要探究socket到底是什么东西。协议栈内部有一块用于存放控制信息的内存空间，记录了通信操作的控制信息，比如通信对象的IP地址、端口号、通信操作的进行状态等。

我们要清楚，套接字只是我们提出的一个概念，并非实体，他其实就是这些控制信息。我们需要委托协议栈执行操作，那么协议栈需要知道对象的IP地址和端口，发送数据后协议栈需要等待返回消息，但有可能数据丢失，等待不到响应，这样的情况下我们不能一直等下去。或者说，需要有一个定时器一样的东西，那么协议栈必须要知道发送数据过了多久。为此，套接字必须记录是否已经收到响应，以及发送数据后过去的时间。

以上例子得到，套接字中记录了用于控制通信操作的各种控制信息，而协议栈又根据这些信息判断下一步的行动，这就是套接字的作用。

### 调用socket的操作

![image-20211120221514610](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211120221514610.png)

协议栈首先会分配用于存放一个套接字所需的内存空间。在套接字的内存空间中写入表示初始状态的控制信息。到这里，创建套接字的操作就完成了。

接下来将文件描述符告诉应用程序，收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有 的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。

## 连接服务器

### 连接的意思和发生的事情

**创建套接字之后，应用程序（浏览器）就会调用 connect，随后协议栈会将本地的套接字与服务器的套接字进行连接。**

是套接字刚刚创建完成时，当应用程序委托发送数据的时候，协议栈会如何操作呢？

**对于客户端**

假设现在是浏览器的客户端，套接字刚创建，里面没有存放信息，不知道这个浏览器的通信对象是谁，协议栈也就不能从套接字获得信息然后操作。这需要浏览器解析域名，得到IP地址并且得知端口号，**而我们在刚创建套接字的时候，这些信息是没有传给协议栈的，所以我们需要连接操作，将服务器的IP地址和端口号等信息告诉协议栈。这也是连接操作的目的之一。**

```C
serv_addr.sin_family = AF_INET;
serv_addr.sin_addr.s_addr = inet_addr(argv[1]);
serv_addr.sin_port = htons(atoi(argv[2]));
// 传递给协议栈
connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
```

**对于服务器端**

假设现在是浏览器想要访问的服务器端，服务器也创建一个套接字，但是它不知道谁要跟他通信，他也不知道自己要跟谁通信（浏览器客户端知道通话对象的IP）。所以，客户端要向服务器告知必要的信息，比如“我想和你开始通信，我的 IP 地址是 xxx.xxx. xxx.xxx，端口号是 yyyy。”可见，客户端向服务器传达开始通信的请求， 也是连接操作的目的之一。

此外，当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作的过程中分配的。

IP 地址和端口号是典型的控制信息。除此之外还有其他一些控制信息

### 负责保存控制信息的头

通信操作中使用的控制信息分为两类。 

- 头部中记录的信息 
- 套接字（协议栈中的内存空间）中记录的信息

### 连接操作的实际过程

```C
connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
```

上面的调用提供了服务器的 IP 地址和端口号，这些信息会传递给协议栈中的 TCP 模块。然后，TCP 模块会与该 IP 地址对应的对象，也就是与服务器的 TCP 模块交换控制信息

然后是服务器与客户端的交互过程

- 首先，客户端先创建一个包含表示开始数据收发操作的控制信息的头部。我们关注里面的重点字段，发送方和接收方的端口号。到这里，客户端（发送方）的套接字就准确找到了服务器（接收 方）的套接字，也就是搞清楚了我应该连接哪个套接字。然后，我们将头部中的控制位的 SYN 比特设置为 1，大家可以认为它`表示连接` 。此外还需 要设置适当的序号和窗口大小
- TCP 头部创建好之后，接下来 TCP 模块会将信息传递给 IP 模块并委托它进行发送 。IP 模块执行网络包发送操作后，网络包就会通过网络到达服务器，**然后服务器上的 IP 模块会将接收到的数据传递给 TCP 模块， 服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字，也就是说，从处于等待连接状态的套接字中找到与 TCP 头部中记录的端口号 相同的套接字就可以了。**当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为`正在连接`。

。。。

## 收发数据

### 将HTTP请求消息交给协议栈

接下来就进入数据收发阶段

```C
write(clnt_sock, message, sizeof(message) - 1);
```

```C
read(sock, message, sizeof(message) - 1);
```

协议栈并不关心应用程序传来的数据是什么内容。在协议栈看来，要发送的数据就是 一定长度的二进制字节序列而已。

协议栈并不是一收到数据就马上发送出去，而是会将数据存放 在内部的发送缓冲区中，并等待应用程序的下一段数据。原因如下

如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送出去。

至于要积累多少数 据才能发送，不同种类和版本的操作系统会有所不同，不能一概而论，但都是根据下面几个要素来判断的。

- 网络包能容纳的数据长度
  - `MTU`表示一个网络包的最大长度，在以太 网中一般是 1500 字节。`MTU `是包含头部的总长度，因此需要从`MTU `减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作`MSSC`。当从应用程序收到的数据长度超过或者接近`MSS`时再发送出去，就可以避免发送大量小包的问题了
- 时间
  - 当应用程序发送数据的频率不高的时候，如果每次都等到长度接近`MSS`时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到`MSS`，也应该果断发送出去。为此，协议栈的内部有一个计时器，当经过一定时间之后， 就会把网络包发送出去.

![image-20211120232927490](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211120232927490.png)

### 对较大的数据进行拆分

如果发送的数据过大，大于了`MSS`，发送缓冲区中的数据会被以`MSS`长度为单位进行拆分，拆分出来的每块数据会被放进单独的网络包中。

<img src="https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211120235451987.png" alt="image-20211120235451987" style="zoom: 80%;" />

### 使用ACK号确认网络包已收到

到这里，网络包已经装好数据并发往服务器了，但数据发送操作还没有结束。TCP 具备确认对方是否成功收到网络包，以及当对方没收到时进 行重发的功能，因此在发送网络包之后，接下来还需要进行确认操作。

TCP在拆分数据时，会计算好每一块数据的字节数，然后将字节数和TCP头部的序列号做计算，将结果更新到序列号中。发送数据的长度也需要告知接收方，不过这个并不是放在 TCP 头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。