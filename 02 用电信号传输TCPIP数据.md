## 了解重点

- 创建套接字
- 连接服务器
- 收发数据
- 从服务器断开连接并删除套接字
- IP与以太网的包收发操作
- 用UDP协议收发数据的操作

补充了很多有用的信息，我们发送数据本质是委托给操作系统，让操作系统里的Socket库里的组件发送的，这其中借助了协议栈，然后层层向下，最后传递过去。协议栈发送数据，那么它得知道发送给谁吧，所以知道IP地址和端口号，我们需要将这个信息告诉他，这些信息相当于一系列的属性，我们想让OS可以直接找到，把这些控制信息组合在一起，命名为套接字如何，是不是对套接字的形成有了一点印象。

## 创建套接字

协议栈内部结构

![image-20211120220115494](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211120220115494.png)

- 浏览器、邮件等一般应用程序收发数据时用 TCP； 

- DNS 查询等收发较短的控制数据时用 UDP。

### 套接字的实体就是通信控制信息

**协议栈是根据套接字中记录的控制信息来工作的**

我们要探究socket到底是什么东西。协议栈内部有一块用于存放控制信息的内存空间，记录了通信操作的控制信息，比如通信对象的IP地址、端口号、通信操作的进行状态等。

我们要清楚，套接字只是我们提出的一个概念，并非实体，他其实就是这些控制信息。我们需要委托协议栈执行操作，那么协议栈需要知道对象的IP地址和端口，发送数据后协议栈需要等待返回消息，但有可能数据丢失，等待不到响应，这样的情况下我们不能一直等下去。或者说，需要有一个定时器一样的东西，那么协议栈必须要知道发送数据过了多久。为此，套接字必须记录是否已经收到响应，以及发送数据后过去的时间。

以上例子得到，套接字中记录了用于控制通信操作的各种控制信息，而协议栈又根据这些信息判断下一步的行动，这就是套接字的作用。

### 调用socket的操作

![image-20211120221514610](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211120221514610.png)

协议栈首先会分配用于存放一个套接字所需的内存空间。在套接字的内存空间中写入表示初始状态的控制信息。到这里，创建套接字的操作就完成了。

接下来将文件描述符告诉应用程序，收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有 的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。

## 连接服务器

### 连接的意思和发生的事情

**创建套接字之后，应用程序（浏览器）就会调用 connect，随后协议栈会将本地的套接字与服务器的套接字进行连接。**

是套接字刚刚创建完成时，当应用程序委托发送数据的时候，协议栈会如何操作呢？

**对于客户端**

假设现在是浏览器的客户端，套接字刚创建，里面没有存放信息，不知道这个浏览器的通信对象是谁，协议栈也就不能从套接字获得信息然后操作。这需要浏览器解析域名，得到IP地址并且得知端口号，**而我们在刚创建套接字的时候，这些信息是没有传给协议栈的，所以我们需要连接操作，将服务器的IP地址和端口号等信息告诉协议栈。这也是连接操作的目的之一。**

```C
serv_addr.sin_family = AF_INET;
serv_addr.sin_addr.s_addr = inet_addr(argv[1]);
serv_addr.sin_port = htons(atoi(argv[2]));
// 传递给协议栈
connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
```

**对于服务器端**

假设现在是浏览器想要访问的服务器端，服务器也创建一个套接字，但是它不知道谁要跟他通信，他也不知道自己要跟谁通信（浏览器客户端知道通话对象的IP）。所以，客户端要向服务器告知必要的信息，比如“我想和你开始通信，我的 IP 地址是 xxx.xxx. xxx.xxx，端口号是 yyyy。”可见，客户端向服务器传达开始通信的请求， 也是连接操作的目的之一。

此外，当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作的过程中分配的。

IP 地址和端口号是典型的控制信息。除此之外还有其他一些控制信息

### 负责保存控制信息的头

通信操作中使用的控制信息分为两类。 

- 头部中记录的信息 
- 套接字（协议栈中的内存空间）中记录的信息

### 连接操作的实际过程

```C
connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
```

上面的调用提供了服务器的 IP 地址和端口号，这些信息会传递给协议栈中的 TCP 模块。然后，TCP 模块会与该 IP 地址对应的对象，也就是与服务器的 TCP 模块交换控制信息

然后是服务器与客户端的交互过程

- 首先，客户端先创建一个包含表示开始数据收发操作的控制信息的头部。我们关注里面的重点字段，发送方和接收方的端口号。到这里，客户端（发送方）的套接字就准确找到了服务器（接收方）的套接字，也就是搞清楚了我应该连接哪个套接字。然后，我们将头部中的控制位的 SYN 比特设置为 1，大家可以认为它`表示连接` 。此外还需 要设置适当的序号和窗口大小
- TCP 头部创建好之后，接下来 TCP 模块会将信息传递给 IP 模块并委托它进行发送 。IP 模块执行网络包发送操作后，网络包就会通过网络到达服务器，**然后服务器上的 IP 模块会将接收到的数据传递给 TCP 模块， 服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字，也就是说，从处于等待连接状态的套接字中找到与 TCP 头部中记录的端口号相同的套接字就可以了。**当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为`正在连接`。

。。。

## 收发数据

### 将HTTP请求消息交给协议栈

接下来就进入数据收发阶段

```C
write(clnt_sock, message, sizeof(message) - 1);
```

```C
read(sock, message, sizeof(message) - 1);-协议栈并不关心应用程序传来的数据是什么内容。在协议栈看来，要发送的数据就是一定长度的二进制字节序列而已。
```

协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。原因如下

如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送出去。

至于要积累多少数据才能发送，不同种类和版本的操作系统会有所不同，不能一概而论，但都是根据下面几个要素来判断的。

- 网络包能容纳的数据长度
  - `MTU`表示一个网络包的最大长度，在以太 网中一般是 1500 字节。`MTU `是包含头部的总长度，因此需要从`MTU `减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作`MSSC`。当从应用程序收到的数据长度超过或者接近`MSS`时再发送出去，就可以避免发送大量小包的问题了
- 时间
  - 当应用程序发送数据的频率不高的时候，如果每次都等到长度接近`MSS`时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到`MSS`，也应该果断发送出去。为此，协议栈的内部有一个计时器，当经过一定时间之后， 就会把网络包发送出去.

![image-20211120232927490](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211120232927490.png)

### 对较大的数据进行拆分

如果发送的数据过大，大于了`MSS`，发送缓冲区中的数据会被以`MSS`长度为单位进行拆分，拆分出来的每块数据会被放进单独的网络包中。

<img src="https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211120235451987.png" alt="image-20211120235451987" style="zoom: 80%;" />

### 使用ACK号确认网络包已收到

到这里，网络包已经装好数据并发往服务器了，但数据发送操作还没有结束。TCP 具备确认对方是否成功收到网络包，以及当对方没收到时进行重发的功能，因此在发送网络包之后，接下来还需要进行确认操作。

TCP在拆分数据时，会计算好每一块数据的字节数，然后将字节数和TCP头部的序列号做计算，将结果更新到序列号中。发送数据的长度也需要告知接收方，不过这个并不是放在 TCP 头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。

**接收方可通过这些信息检查收到的网络包有没有遗漏**

...

### 根据网络包平均往返时间调整ACK号等待时间

当网络传输繁忙时就会发生拥塞，ACK 号的返回会变慢，这时我们就必须将等待时间设置得稍微长一点，否则可能会发生已经重传了包之后， 前面的 ACK 号才姗姗来迟的情况。

等待时间需要设为一个合适的值，不能太长也不能太短。TCP 采用了动态调整等待时间的方法，这个等待时间是根据 ACK 号返回所需的时间来判断的。具体来说，TCP 会在发送数据 的过程中持续测量 ACK 号的返回时间，如果 ACK 号返回变慢，则相应 延长等待时间；相对地，如果 ACK 号马上就能返回，则相应缩短等待时间 。

### 使用窗口有效管理 ACK 号

![image-20211121121711419](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211121121711419.png)

为了利用等待ACK的时间，TCP采用了滑动窗口方式。

> 问题：但如果不等返回 ACK 号就连续发送包，就有 可能会出现发送包的频率超过接收方处理能力的情况。

当接收方的 TCP 收到包后，会先将数据存放到 接收缓冲区中。然后，接收方需要计算 ACK 号，将数据块组装起来还原成原本的数据并传递给应用程序，如果这些操作还没完成下一个包就到了，那么也会被存入缓冲区中，**如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快，那么接收缓冲区中 的数据就会越堆越多，最后就会溢出。**缓冲区溢出之后，后面的数据就进不来了，因此接收方就收不到后面的包了。

> 我们可以通过下面的方法来避免 这种情况的发生。

首先，接收方需要告诉发送方自己最多能接收多少数据， 然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口方式的基本思路。

![image-20211121122107540](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211121122107540.png)

图上看似乎接收方一直在接收数据，什么都不做，但其实接到数据包后就直接处理了，如果接收方的性能高，处理速度比包的到达速率还快，缓冲区马上就会被清空，并通过窗口字段告知发送方。

最大数据量即为报头的窗口大小

### ACK 与窗口的合并

略

### 接收HTTP响应消息

协议栈尝试从接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。这时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起，等服务器返回的响应消息到达之后再继续执行接收操作。

**具体操作**

首先，协议栈会检查收到的数据块和 TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号。然后，协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序。具体来说，协议栈会将接收到的 数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。 将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新。

## 从服务器断开并删除套接字

假设服务器一方断开连接，

...

## IP与以太网的包收发操作

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成包发送给通信对象。我们需要讲解以下IP模块

包是由头部和数据两部分构成的。头部包含目的地址等控制信息，可以把它理解为快递包裹的面单；头部后面就是委托方要发送给对方的数据，也就相当于快递包裹里的货物。

![image-20211121155957073](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211121155957073.png)

![image-20211121155950811](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211121155950811.png)

首先，发送方的网络设备会负责创建包，创建包的过程就是生成含有正确控制信息的头部，然后再附加上要发送的数据。

接下来，包会被发往最近的网络转发设备。当到达最近的转发设备之后，转发设备会根据头部中的信息判断接下来应该发往哪里。这个过程需要用到一张表，这张表里面记录了每一个地址对应的发送方向，也就是按照头部里记录的目的地址在表里进行查询，并根据查到的信息判断接下来应该发往哪个方向。

比如， 如果查表的结果是“目标地址为 ×××× 的包应该发到 ×××× 号线路”，那么转发设备就会把这个包发到 ×××× 号线路去。接下来，包在向目的地移动的过程中，又会到达下一个转发设备，然后又会按照同样的 方式被发往下一个转发设备。

就这样，经过多个转发设备的接力之后，包最终就会到达接收方的网络设备。当然，发送方向接收方发送一个包，接收方可能也会向发送方返回一个包，此时的发送方到了接下来的某个时刻就会变成接收方。因此，我们不需要把发送方和接收方明确区分开来，在这里我们把发送方和接收方统称为终端节点。

**路由器和集线器的分工**

- 路由器根据目标地址判断下一个路由器的位置
- 集线器在子网中将网络包传输到下一个路由

实际上，集线器是按照以太网规则传输包的设备，而路由器是按照 IP 规则传输包的设备，因此我们也可以作如下理解。

- IP 协议根据目标地址判断下一个 IP 转发设备的位置 
- 子网中的以太网协议将包传输到下一个转发设备

**TCP/IP包包含如下两个头部**

- MAC头部
- IP头部

发送方发送数据，要把目的的IP地址写入IP头部中，IP协议根据地址找包的传输方向，从而找到下一个路由器的位置。

之后，IP协议委托以太网协议将包传输过去。那么以太网协议也要知道自己的目的地才行，这也靠IP协议完成。IP协议会查找下一个路由器的以太网地址，并将这个地址写入MAC头部，这样以太网协议就知道要将这个包发送到哪个路由器上了。

网络包传输的过程会经过集线器，集线器是根据以太网协议工作的设备。里面有用于以太网协议的表，记录各个目的信息，可以根据以太网头部记录的信息查找表，得到方向。

到达下一个路由器，路由器有用于IP协议的表，可根据这个表和IP头部中的目的信息查到下一个路由器位置。而且，我们还需查出下一个路由的MAC地址。

![image-20211121161257273](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211121161257273.png)
